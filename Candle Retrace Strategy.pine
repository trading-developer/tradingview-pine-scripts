Script Name: Candle Retrace Strategy
Author: UnknownUnicorn36161431
Description: The WHAT
=============>
A strategy focused on opening trades during a retracement of the so-called Big Candles. Instead of having to recalibrate a strategy every so often (so it stays consistent with the current trend), this Candle strategy tries to use a different approach. It will detect candles with big bodies (which are usually created during a strong push...
PineScript code:

Pine Scriptâ„¢ strategy
Candle Retrace Strategy
//@version=5
strategy(title  =  "Candle  Retrace  Strategy",  shorttitle="Retrace  Strategy",  overlay=true,  process_orders_on_close  =  false,  calc_on_order_fills  =  false,  pyramiding  =  0,  default_qty_type  =  strategy.percent_of_equity,  default_qty_value  =  75,  commission_type  =  strategy.commission.percent,  commission_value  =  0.04,  initial_capital  =  100,  max_labels_count  =  500,  max_lines_count  =  500,  max_bars_back  =  5000)
AUTO  =  "Auto"
DAILY  =  "Daily"
WEEKLY  =  "Weekly"
MONTHLY  =  "Monthly"
QUARTERLY  =  "Quarterly"
YEARLY  =  "Yearly"
BIYEARLY  =  "Biyearly"
TRIYEARLY  =  "Triyearly"
QUINQUENNIALLY  =  "Quinquennially"
DECENNIALLY  =  "Decennially"
TRADITIONAL  =  "Traditional"
FIBONACCI  =  "Fibonacci"
WOODIE  =  "Woodie"
CLASSIC  =  "Classic"
DEMARK  =  "DM"
CAMARILLA  =  "Camarilla"
GROUP_DETECTION  =  "Big  Candle  Detection"
GROUP_RETRACEMENT  =  "Retracement  Options"
GROUP_LIMITATIONS  =  "Limitation  Options"
GROUP_PIVOTS  =  "Pivot  Points"
GROUP_CRSI_OPTIONS  =  "cRSI  Options"
GROUP_HTF_MESA_MA  =  "HTF  Adaptive  MESA  MA  Options"
//  BIG  CANDLES
size  =  input.float(  1.2,  "Big  Candle  Minimum  Size",  minval  =  0.01,  step  =  0.1,  inline  =  "candlesize",  group  =  GROUP_DETECTION  )
percentage  =  input.bool(  true,  "Percentage",  inline  =  "candlesize",  group  =  GROUP_DETECTION  )
//disable_2_subsequent_big_candles  =  input.bool(  false,  "Disable  2  Subsequent  Big  Candles",  tooltip="If  this  option  is  ON,  then  any  newfound  Big  Candle  in  the  opposite  direction  will  be  disregarded  and  the  old  Big  Candle  will  be  kept  for  retracement  recognition.  For  instance,  when  a  green  Big  Candle  is  immediatelly  followed  by  a  red  Big  Candle,  the  red  one  is  ignored  and  all  subsequent  retracement  checks  are  made  against  the  first,  green  Big  Candle.\n\nThis  is  a  tradeoff  option,  as  it  might  bring  higher  rewards  in  some  case  but  lower  in  others,  depending  on  the  asset  being  traded.",  group  =  GROUP_DETECTION  )
//  RETRACEMENT
min_retracement  =  input.float(  30,  "Minimum  Retracement  %",  step=1,  tooltip="When  current  candle  retraces  at  least  this  much  %  of  the  previous  big  candle,  consider  this  a  trade  signal.",  group  =  GROUP_RETRACEMENT  )
extend_sl_by  =  input.float(  0,  "Extend  SL  by  this  much  %",  step=1,  tooltip="Stop  Loss  is  trigerred  at  the  high/low  side  of  the  previous  candle.  This  option  will  allow  to  extend  (or  contract  if  you  use  negative  value)  that  SL  value  by  the  given  percentage.",  group  =  GROUP_RETRACEMENT  )
extend_tp_by  =  input.float(  0,  "Extend  TP  by  this  much  %",  step=1,  tooltip="Take  Profit  is  trigerred  at  the  highest  high  /  lowest  low  of  the  previous  uninterrupted  trend  (i.e.  all  previous  candles  with  the  same  color  until  an  opposite  candle  is  found).  This  option  will  allow  to  extend  (or  contract  if  you  use  negative  value)  that  TP  value  by  the  given  percentage.",  group  =  GROUP_RETRACEMENT  )
max_sl_percent  =  input.float(  0,  "[Optional]  Maximum  SL  %",  minval=0,  step=0.1,  tooltip="You  can  choose  to  have  SL  at  maximum  this  much  percent  from  the  entry  price.",  group  =  GROUP_RETRACEMENT  )
require_previous_same_bars  =  input.int(  1,  "[Optional]  Min  previous  bars  in  same  trend",  minval=0,  step=1,  tooltip="If  you  set  this  to  anything  above  0,  the  strategy  will  make  sure  there  is  at  least  this  number  of  previous  bars  with  the  same  direction  as  the  Big  Candle.",  group  =  GROUP_RETRACEMENT  )
sl_ends_with_trend  =  input.bool(  false,  "Adjust  SL  to  End  With  Trend",  tooltip="When  this  option  is  ON,  Stop  Loss  is  moved  to  the  last  candle  high/low  in  the  same  trend  after  the  Big  Candle.  For  instance,  if  a  green  Big  Candle  still  had  2  smaller  candles  making  a  higher  high  after  it,  SL  will  be  moved  to  the  highest  high  they  did  in  that  trend.\n\nIf  this  option  is  OFF,  Stop  Loss  will  be  set  at  the  high/low  of  the  actual  Big  Candle  itself  (which  makes  for  better  risk  management  but  also  smaller  potential  reward).",  group  =  GROUP_RETRACEMENT  )
//  PIVOTS
pivots_info  =  input.bool(true,  "Pivot  Points  Info",  tooltip="This  strategy  uses  pivot  points  to  check  whether  the  Big  Candle  crosses  at  least  1  pivot  point  -  which  signals  a  really  strong  candle.\n\nIf  a  candle  crosses  multiple  pivot  points  in  one  go,  it  is  automatically  considered  tradeable.  Otherwise,  a  Big  Candle  needs  to  cross  the  pivot  point  with  at  least  the  predefined  %  of  its  height  to  be  considered  tradeable.\n\nYou  can  set  which  type  of  pivot  points  and  their  settings  you  want  to  use  below.  The  default  (with  best  results  in  my  testing)  is  the  'Camarilla'  pivot  points  type  but  feel  free  to  experiment  with  your  own.",  group=GROUP_PIVOTS)
pivot_cross_by_at_least_perc  =  input.float(  50,  "Big  Candle  to  cross  Pivot  by  at  least  %",  step=1,  tooltip="This  is  the  minimum  percentage  by  which  a  Big  Candle  needs  to  cross  a  single  Pivot  Point  in  order  for  this  candle  to  be  considered  tradeable.",  group  =  GROUP_PIVOTS  )
kind  =  input.string(title="Type",  defval="Camarilla",  options=[TRADITIONAL,  FIBONACCI,  WOODIE,  CLASSIC,  DEMARK,  CAMARILLA],  group=GROUP_PIVOTS)
pivot_time_frame  =  input.string(title="Pivots  Timeframe",  defval=AUTO,  options=[AUTO,  DAILY,  WEEKLY,  MONTHLY,  QUARTERLY,  YEARLY,  BIYEARLY,  TRIYEARLY,  QUINQUENNIALLY,  DECENNIALLY],  group=GROUP_PIVOTS)
look_back  =  input.int(title="Number  of  Pivots  Back",  defval=25,  minval=1,  maxval=5000,  group=GROUP_PIVOTS)
is_daily_based  =  input.bool(title="Use  Daily-based  Values",  defval=true,  tooltip="When  this  option  is  unchecked,  Pivot  Points  will  use  intraday  data  while  calculating  on  intraday  charts.  If  Extended  Hours  are  displayed  on  the  chart,  they  will  be  taken  into  account  during  the  pivot  level  calculation.  If  intraday  OHLC  values  are  different  from  daily-based  values  (normal  for  stocks),  the  pivot  levels  will  also  differ.",  group=GROUP_PIVOTS)
show_labels  =  input.bool(title="Show  Labels",  defval=true,  group=GROUP_PIVOTS)
show_prices  =  input.bool(title="Show  Prices",  defval=true,  group=GROUP_PIVOTS)
position_labels  =  input.string("Left",  "Labels  Position",  options=["Left",  "Right"],  group=GROUP_PIVOTS)
line_width  =  input.int(title="Line  Width",  defval=1,  minval=1,  maxval=100,  group=GROUP_PIVOTS)
i_use_crsi  =  input.bool(  false,  "Open  Trades  by  cRSI",  group  =  GROUP_CRSI_OPTIONS  )
i_show_crsi  =  input.bool(  false,  "Show  cRSI  Pivots",  group  =  GROUP_CRSI_OPTIONS  )
i_i_len      =  input(  15,  "cRSI  EMA  period",  group  =  GROUP_CRSI_OPTIONS  )
i_src          =  input.source(  close,  'cRSI  Source',    group  =  GROUP_CRSI_OPTIONS  )
i_use_htf_mesa  =  input.bool(  false,  "Trade  by  HTF  Adaptive  MESA  MA",  group  =  GROUP_HTF_MESA_MA  )
i_show_htf_mesa  =  input.bool(  false,  "Show  HFT  Adaptive  MESA  MA",  group  =  GROUP_HTF_MESA_MA  )
_tf  =  input.timeframe(  'D',  "HTF  Adaptive  MESA  MA  Resolution",  group  =  GROUP_HTF_MESA_MA  )
var  DEF_COLOR  =  #FB8C00
var  arr_time  =  array.new_int()
var  p  =  array.new_float()
p_color  =  input.color(DEF_COLOR,  "P[U+200F]    [U+200F]    [U+200F]",  inline="P",  group=GROUP_PIVOTS)
p_show  =  input.bool(true,  "",  inline="P",  group=GROUP_PIVOTS)
var  r1  =  array.new_float()
var  s1  =  array.new_float()
s1_color  =  input.color(DEF_COLOR,  "S1",  inline="S1/R1"  ,  group=GROUP_PIVOTS)
s1_show  =  input.bool(true,  "",  inline="S1/R1",  group=GROUP_PIVOTS)
r1_color  =  input.color(DEF_COLOR,  "[U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]R1",  inline="S1/R1",  group=GROUP_PIVOTS)
r1_show  =  input.bool(true,  "",  inline="S1/R1",  group=GROUP_PIVOTS)
var  r2  =  array.new_float()
var  s2  =  array.new_float()
s2_color  =  input.color(DEF_COLOR,  "S2",  inline="S2/R2",  group=GROUP_PIVOTS)
s2_show  =  input.bool(true,  "",  inline="S2/R2",  group=GROUP_PIVOTS)
r2_color  =  input.color(DEF_COLOR,  "[U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]R2",  inline="S2/R2",  group=GROUP_PIVOTS)
r2_show  =  input.bool(true,  "",  inline="S2/R2",  group=GROUP_PIVOTS)
var  r3  =  array.new_float()
var  s3  =  array.new_float()
s3_color  =  input.color(DEF_COLOR,  "S3",  inline="S3/R3",  group=GROUP_PIVOTS)
s3_show  =  input.bool(true,  "",  inline="S3/R3",  group=GROUP_PIVOTS)
r3_color  =  input.color(DEF_COLOR,  "[U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]R3",  inline="S3/R3",  group=GROUP_PIVOTS)
r3_show  =  input.bool(true,  "",  inline="S3/R3",  group=GROUP_PIVOTS)
var  r4  =  array.new_float()
var  s4  =  array.new_float()
s4_color  =  input.color(DEF_COLOR,  "S4",  inline="S4/R4",  group=GROUP_PIVOTS)
s4_show  =  input.bool(true,  "",  inline="S4/R4",  group=GROUP_PIVOTS)
r4_color  =  input.color(DEF_COLOR,  "[U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]R4",  inline="S4/R4",  group=GROUP_PIVOTS)
r4_show  =  input.bool(true,  "",  inline="S4/R4",  group=GROUP_PIVOTS)
var  r5  =  array.new_float()
var  s5  =  array.new_float()
s5_color  =  input.color(DEF_COLOR,  "S5",  inline="S5/R5",  group=GROUP_PIVOTS)
s5_show  =  input.bool(true,  "",  inline="S5/R5",  group=GROUP_PIVOTS)
r5_color  =  input.color(DEF_COLOR,  "[U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]    [U+200F]R5",  inline="S5/R5",  group=GROUP_PIVOTS)
r5_show  =  input.bool(true,  "",  inline="S5/R5",  group=GROUP_PIVOTS)
i_use_time_limited_backtesting  =  input.bool(  false,  "Use  Time-Limited  Backtesting",  group  =  "Time-Limit  BackTests  (0  =  disable)"  )
startDay  =  input.int(0,  "Start  Day",  minval  =  0,  maxval  =  31,  group  =  "Time-Limit  BackTests  (0  =  disable)")
startMonth  =  input.int(0,  "Start  Month",  minval  =  0,  maxval  =  12,  group  =  "Time-Limit  BackTests  (0  =  disable)")
startYear  =  input.int(0,  "Start  Year",  minval  =  0,  maxval  =  2100,  group  =  "Time-Limit  BackTests  (0  =  disable)")
endDay  =  input.int(0,  "End  Day",  minval  =  0,  maxval  =  31,  group  =  "Time-Limit  BackTests  (0  =  disable)")
endMonth  =  input.int(0,  "End  Month",  minval  =  0,  maxval  =  12,  group  =  "Time-Limit  BackTests  (0  =  disable)")
endYear  =  input.int(0,  "End  Year",  minval  =  0,  maxval  =  2100,  group  =  "Time-Limit  BackTests  (0  =  disable)")
inDateRange  =  true
//  Look  if  the  close  time  of  the  current  bar  falls  inside  the  date  range
if  i_use_time_limited_backtesting  and  startDay  !=  0  and  startMonth  !=  0  and  startYear  !=  0  and  endDay  !=  0  and  endMonth  !=  0  and  endYear  !=  0
        inDateRange  :=  (  time  >=  timestamp(  syminfo.timezone,  startYear,  startMonth,  startDay,  0,  0  )  )  and  (  time  <  timestamp(  syminfo.timezone,  endYear,  endMonth,  endDay,  0,  0  )  )
var  exit_price  =  0.0
var  sl_price  =  0.0
var  cRSI_high_extreme_found  =  0.0
var  cRSI_high_extreme_valid  =  true
var  cRSI_low_extreme_found  =  0.0
var  cRSI_low_extreme_valid  =  true
var  last_cRSI_extreme  =  ""
var  cRSI_trend_direction  =  ""
var  mesa_ma_trend_direction  =  ""
var  last_big_candle_retrace_level  =  0.0
var  last_big_candle_type  =  ""
var  last_big_candle_high  =  0.0
var  last_big_candle_low  =  0.0
var  last_big_candle_open  =  0.0
var  last_big_candle_close  =  0.0
var  last_big_candle_pivots_closed  =  array.new_float(  11  )
if  array.size(  last_big_candle_pivots_closed  )  ==  0
        array.fill(  last_big_candle_pivots_closed,  0.0,  0,  10  )
//  PIVOTS  CODE
pivotX_open  =  float(na)
pivotX_open  :=  nz(pivotX_open[1],  open)
pivotX_high  =  float(na)
pivotX_high  :=  nz(pivotX_high[1],  high)
pivotX_low  =  float(na)
pivotX_low  :=  nz(pivotX_low[1],  low)
pivotX_prev_open  =  float(na)
pivotX_prev_open  :=  nz(pivotX_prev_open[1])
pivotX_prev_high  =  float(na)
pivotX_prev_high  :=  nz(pivotX_prev_high[1])
pivotX_prev_low  =  float(na)
pivotX_prev_low  :=  nz(pivotX_prev_low[1])
pivotX_prev_close  =  float(na)
pivotX_prev_close  :=  nz(pivotX_prev_close[1])
get_pivot_resolution()  =>
        resolution  =  "M"
        if  pivot_time_frame  ==  AUTO
                if  timeframe.isintraday
                    resolution:=timeframe.multiplier<=15?"D":"W"
elseiftimeframe.isweeklyortimeframe.ismonthly
resolution:="12M"
elseifpivot_time_frame==DAILY
resolution:="D"
elseifpivot_time_frame==WEEKLY
resolution:="W"
elseifpivot_time_frame==MONTHLY
resolution:="M"
elseifpivot_time_frame==QUARTERLY
resolution:="3M"
elseifpivot_time_frame==YEARLYorpivot_time_frame==BIYEARLYorpivot_time_frame==TRIYEARLYorpivot_time_frame==QUINQUENNIALLYorpivot_time_frame==DECENNIALLY
resolution:="12M"
resolution
varlines=array.new_line()
varlabels=array.new_label()
draw_line(i,pivot,col)=>
ifarray.size(arr_time)>1
array.push(lines,line.new(array.get(arr_time,i),array.get(pivot,i),array.get(arr_time,i+1),array.get(pivot,i),color=col,xloc=xloc.bar_time,width=line_width))
draw_label(i,y,txt,txt_color)=>
if(show_labelsorshow_prices)andnotna(y)
display_text=(show_labels?txt:"")+(show_prices?str.format("({0})",math.round_to_mintick(y)):"")
label_style=position_labels=="Left"?label.style_label_right:label.style_label_left
x=position_labels=="Left"?array.get(arr_time,i):array.get(arr_time,i+1)
array.push(labels,label.new(x=x,y=y,text=display_text,textcolor=txt_color,style=label_style,color=#00000000,xloc=xloc.bar_time))
traditional()=>
pivotX_Median=(pivotX_prev_high+pivotX_prev_low+pivotX_prev_close)/3
array.push(p,pivotX_Median)
array.push(r1,pivotX_Median*2-pivotX_prev_low)
array.push(s1,pivotX_Median*2-pivotX_prev_high)
array.push(r2,pivotX_Median+1*(pivotX_prev_high-pivotX_prev_low))
array.push(s2,pivotX_Median-1*(pivotX_prev_high-pivotX_prev_low))
array.push(r3,pivotX_Median*2+(pivotX_prev_high-2*pivotX_prev_low))
array.push(s3,pivotX_Median*2-(2*pivotX_prev_high-pivotX_prev_low))
array.push(r4,pivotX_Median*3+(pivotX_prev_high-3*pivotX_prev_low))
array.push(s4,pivotX_Median*3-(3*pivotX_prev_high-pivotX_prev_low))
array.push(r5,pivotX_Median*4+(pivotX_prev_high-4*pivotX_prev_low))
array.push(s5,pivotX_Median*4-(4*pivotX_prev_high-pivotX_prev_low))
fibonacci()=>
pivotX_Median=(pivotX_prev_high+pivotX_prev_low+pivotX_prev_close)/3
pivot_range=pivotX_prev_high-pivotX_prev_low
array.push(p,pivotX_Median)
array.push(r1,pivotX_Median+0.382*pivot_range)
array.push(s1,pivotX_Median-0.382*pivot_range)
array.push(r2,pivotX_Median+0.618*pivot_range)
array.push(s2,pivotX_Median-0.618*pivot_range)
array.push(r3,pivotX_Median+1*pivot_range)
array.push(s3,pivotX_Median-1*pivot_range)
woodie()=>
pivotX_Woodie_Median=(pivotX_prev_high+pivotX_prev_low+pivotX_open*2)/4
pivot_range=pivotX_prev_high-pivotX_prev_low
array.push(p,pivotX_Woodie_Median)
array.push(r1,pivotX_Woodie_Median*2-pivotX_prev_low)
array.push(s1,pivotX_Woodie_Median*2-pivotX_prev_high)
array.push(r2,pivotX_Woodie_Median+1*pivot_range)
array.push(s2,pivotX_Woodie_Median-1*pivot_range)
pivot_point_r3=pivotX_prev_high+2*(pivotX_Woodie_Median-pivotX_prev_low)
pivot_point_s3=pivotX_prev_low-2*(pivotX_prev_high-pivotX_Woodie_Median)
array.push(r3,pivot_point_r3)
array.push(s3,pivot_point_s3)
array.push(r4,pivot_point_r3+pivot_range)
array.push(s4,pivot_point_s3-pivot_range)
classic()=>
pivotX_Median=(pivotX_prev_high+pivotX_prev_low+pivotX_prev_close)/3
pivot_range=pivotX_prev_high-pivotX_prev_low
array.push(p,pivotX_Median)
array.push(r1,pivotX_Median*2-pivotX_prev_low)
array.push(s1,pivotX_Median*2-pivotX_prev_high)
array.push(r2,pivotX_Median+1*pivot_range)
array.push(s2,pivotX_Median-1*pivot_range)
array.push(r3,pivotX_Median+2*pivot_range)
array.push(s3,pivotX_Median-2*pivot_range)
array.push(r4,pivotX_Median+3*pivot_range)
array.push(s4,pivotX_Median-3*pivot_range)
demark()=>
pivotX_Demark_X=pivotX_prev_high+pivotX_prev_low*2+pivotX_prev_close
ifpivotX_prev_close==pivotX_prev_open
pivotX_Demark_X:=pivotX_prev_high+pivotX_prev_low+pivotX_prev_close*2
ifpivotX_prev_close>pivotX_prev_open
pivotX_Demark_X:=pivotX_prev_high*2+pivotX_prev_low+pivotX_prev_close
array.push(p,pivotX_Demark_X/4)
array.push(r1,pivotX_Demark_X/2-pivotX_prev_low)
array.push(s1,pivotX_Demark_X/2-pivotX_prev_high)
camarilla()=>
pivotX_Median=(pivotX_prev_high+pivotX_prev_low+pivotX_prev_close)/3
pivot_range=pivotX_prev_high-pivotX_prev_low
array.push(p,pivotX_Median)
array.push(r1,pivotX_prev_close+pivot_range*1.1/12.0)
array.push(s1,pivotX_prev_close-pivot_range*1.1/12.0)
array.push(r2,pivotX_prev_close+pivot_range*1.1/6.0)
array.push(s2,pivotX_prev_close-pivot_range*1.1/6.0)
array.push(r3,pivotX_prev_close+pivot_range*1.1/4.0)
array.push(s3,pivotX_prev_close-pivot_range*1.1/4.0)
array.push(r4,pivotX_prev_close+pivot_range*1.1/2.0)
array.push(s4,pivotX_prev_close-pivot_range*1.1/2.0)
r5_val=pivotX_prev_high/pivotX_prev_low*pivotX_prev_close
array.push(r5,r5_val)
array.push(s5,2*pivotX_prev_close-r5_val)
calc_pivot()=>
ifkind==TRADITIONAL
traditional()
elseifkind==FIBONACCI
fibonacci()
elseifkind==WOODIE
woodie()
elseifkind==CLASSIC
classic()
elseifkind==DEMARK
demark()
elseifkind==CAMARILLA
camarilla()
resolution=get_pivot_resolution()
SIMPLE_DIVISOR=-1
custom_years_divisor=switchpivot_time_frame
BIYEARLY=>2
TRIYEARLY=>3
QUINQUENNIALLY=>5
DECENNIALLY=>10
=>SIMPLE_DIVISOR
calc_high(prev,curr)=>
ifna(prev)orna(curr)
nz(prev,nz(curr,na))
else
math.max(prev,curr)

calc_low(prev,curr)=>
ifnotna(prev)andnotna(curr)
math.min(prev,curr)
else
nz(prev,nz(curr,na))
calc_OHLC_for_pivot(custom_years_divisor)=>
ifcustom_years_divisor==SIMPLE_DIVISOR
[open,high,low,close,open[1],high[1],low[1],close[1],time[1],time_close]
else
varprev_sec_open=float(na)
varprev_sec_high=float(na)
varprev_sec_low=float(na)
varprev_sec_close=float(na)
varprev_sec_time=int(na)
varcurr_sec_open=float(na)
varcurr_sec_high=float(na)
varcurr_sec_low=float(na)
varcurr_sec_close=float(na)
ifyear(time_close)%custom_years_divisor==0
curr_sec_open:=open
curr_sec_high:=high
curr_sec_low:=low
curr_sec_close:=close
prev_sec_high:=high[1]
prev_sec_low:=low[1]
prev_sec_close:=close[1]
prev_sec_time:=time[1]
fori=2tocustom_years_divisor
prev_sec_open:=nz(open[i],prev_sec_open)
prev_sec_high:=calc_high(prev_sec_high,high[i])
prev_sec_low:=calc_low(prev_sec_low,low[i])
prev_sec_time:=nz(time[i],prev_sec_time)
[curr_sec_open,curr_sec_high,curr_sec_low,curr_sec_close,prev_sec_open,prev_sec_high,prev_sec_low,prev_sec_close,prev_sec_time,time_close]
[sec_open,sec_high,sec_low,sec_close,prev_sec_open,prev_sec_high,prev_sec_low,prev_sec_close,prev_sec_time,sec_time]=request.security(syminfo.tickerid,resolution,calc_OHLC_for_pivot(custom_years_divisor),lookahead=barmerge.lookahead_on)
sec_open_gaps_on=request.security(syminfo.tickerid,resolution,open,gaps=barmerge.gaps_on,lookahead=barmerge.lookahead_on)
is_change_years=custom_years_divisor>0andta.change(time(resolution))andyear(time_close)%custom_years_divisor==0
varis_change=false
varuses_current_bar=timeframe.isintradayandkind==WOODIE
varchange_time=int(na)
is_time_change=(ta.change(time(resolution))andcustom_years_divisor==SIMPLE_DIVISOR)oris_change_years
ifis_time_change
change_time:=time
varstart_time=time
varwas_last_premarket=false
varstart_calculate_in_premarket=false
is_last_premarket=barstate.islastandsession.ispremarketandtime_close>sec_timeandnotwas_last_premarket
ifis_last_premarket
was_last_premarket:=true
start_calculate_in_premarket:=true
ifsession.ismarket
was_last_premarket:=false

without_time_change=barstate.islastandarray.size(arr_time)==0
is_can_calc_pivot=(notuses_current_barandis_time_changeandsession.ismarket)or(ta.change(sec_open)andnotstart_calculate_in_premarket)oris_last_premarketor(uses_current_barandnotna(sec_open_gaps_on))orwithout_time_change
enough_bars_for_calculate=prev_sec_time>=start_timeoris_daily_based
ifis_can_calc_pivotandenough_bars_for_calculate
ifarray.size(arr_time)==0andis_daily_based
pivotX_prev_open:=prev_sec_open[1]
pivotX_prev_high:=prev_sec_high[1]
pivotX_prev_low:=prev_sec_low[1]
pivotX_prev_close:=prev_sec_close[1]
pivotX_open:=sec_open[1]
pivotX_high:=sec_high[1]
pivotX_low:=sec_low[1]
array.push(arr_time,start_time)
calc_pivot()

ifis_daily_based
ifis_last_premarket
pivotX_prev_open:=sec_open
pivotX_prev_high:=sec_high
pivotX_prev_low:=sec_low
pivotX_prev_close:=sec_close
pivotX_open:=open
pivotX_high:=high
pivotX_low:=low
else
pivotX_prev_open:=prev_sec_open
pivotX_prev_high:=prev_sec_high
pivotX_prev_low:=prev_sec_low
pivotX_prev_close:=prev_sec_close
pivotX_open:=sec_open
pivotX_high:=sec_high
pivotX_low:=sec_low
else
pivotX_prev_high:=pivotX_high
pivotX_prev_low:=pivotX_low
pivotX_prev_open:=pivotX_open
pivotX_prev_close:=close[1]
pivotX_open:=open
pivotX_high:=high
pivotX_low:=low
ifbarstate.islastandnotis_changeandarray.size(arr_time)>0andnotwithout_time_change
array.set(arr_time,array.size(arr_time)-1,change_time)
elseifwithout_time_change
array.push(arr_time,start_time)
else
array.push(arr_time,nz(change_time,time))
calc_pivot()
ifarray.size(arr_time)>look_back
ifarray.size(arr_time)>0
array.shift(arr_time)
ifarray.size(p)>0andp_show
array.shift(p)
ifarray.size(r1)>0andr1_show
array.shift(r1)
ifarray.size(s1)>0ands1_show
array.shift(s1)
ifarray.size(r2)>0andr2_show
array.shift(r2)
ifarray.size(s2)>0ands2_show
array.shift(s2)
ifarray.size(r3)>0andr3_show
array.shift(r3)
ifarray.size(s3)>0ands3_show
array.shift(s3)
ifarray.size(r4)>0andr4_show
array.shift(r4)
ifarray.size(s4)>0ands4_show
array.shift(s4)
ifarray.size(r5)>0andr5_show
array.shift(r5)
ifarray.size(s5)>0ands5_show
array.shift(s5)
is_change:=true
elseifnotis_daily_based
pivotX_high:=math.max(pivotX_high,high)
pivotX_low:=math.min(pivotX_low,low)
ifbarstate.islastandnotis_daily_basedandarray.size(arr_time)==0
runtime.error("NotenoughintradaydatatocalculatePivotPoints.LowerthePivotsTimeframeorturnonthe'UseDaily-basedValues'optionintheindicatorsettings.")
ifbarstate.islastandarray.size(arr_time)>0andis_change
is_change:=false
ifcustom_years_divisor>0
last_pivot_time=array.get(arr_time,array.size(arr_time)-1)
pivot_timeframe=str.tostring(12*custom_years_divisor)+"M"
estimate_pivot_time=last_pivot_time+timeframe.in_seconds(pivot_timeframe)*1000
array.push(arr_time,estimate_pivot_time)
else
array.push(arr_time,time_close(resolution))
fori=0toarray.size(lines)-1
ifarray.size(lines)>0
line.delete(array.shift(lines))
ifarray.size(labels)>0
label.delete(array.shift(labels))
fori=0toarray.size(arr_time)-2
ifarray.size(p)>0andp_show
draw_line(i,p,p_color)
draw_label(i,array.get(p,i),"P",p_color)
ifarray.size(r1)>0andr1_show
draw_line(i,r1,r1_color)
draw_label(i,array.get(r1,i),"R1",r1_color)
ifarray.size(s1)>0ands1_show
draw_line(i,s1,s1_color)
draw_label(i,array.get(s1,i),"S1",s1_color)
ifarray.size(r2)>0andr2_show
draw_line(i,r2,r2_color)
draw_label(i,array.get(r2,i),"R2",r2_color)
ifarray.size(s2)>0ands2_show
draw_line(i,s2,s2_color)
draw_label(i,array.get(s2,i),"S2",s2_color)
ifarray.size(r3)>0andr3_show
draw_line(i,r3,r3_color)
draw_label(i,array.get(r3,i),"R3",r3_color)
ifarray.size(s3)>0ands3_show
draw_line(i,s3,s3_color)
draw_label(i,array.get(s3,i),"S3",s3_color)
ifarray.size(r4)>0andr4_show
draw_line(i,r4,r4_color)
draw_label(i,array.get(r4,i),"R4",r4_color)
ifarray.size(s4)>0ands4_show
draw_line(i,s4,s4_color)
draw_label(i,array.get(s4,i),"S4",s4_color)
ifarray.size(r5)>0andr5_show
draw_line(i,r5,r5_color)
draw_label(i,array.get(r5,i),"R5",r5_color)
ifarray.size(s5)>0ands5_show
draw_line(i,s5,s5_color)
draw_label(i,array.get(s5,i),"S5",s5_color)
//------------------------------------------------------------------------------
//cRSIindicatorcode
//------------------------------------------------------------------------------
crsi=0.0
vibration=10
torque=0.618/(vibration+1)
phasingLag=(vibration-1)/0.618
rsi=ta.rsi(i_src,i_i_len)
crsi:=torque*(2*rsi-rsi[phasingLag])+(1-torque)*nz(crsi[1])
floatosc=crsi
floatph=ta.highestbars(high,i_i_len)==0?osc:na
floatpl=ta.lowestbars(low,i_i_len)==0?osc:na
varintdir=0
dir:=phandna(pl)?1:plandna(ph)?-1:dir
varmax_array_size=10
vararr_zz=array.new_float(0)
older_zz=array.copy(arr_zz)
dirchanged=ta.change(dir)
add_to_zigzag(_id,floatvalue,intbindex)=>
array.unshift(_id,bindex)
array.unshift(_id,value)
ifarray.size(_id)>max_array_size
array.pop(_id)
array.pop(_id)
update_zigzag(_id,floatvalue,intbindex,intdir)=>
ifarray.size(_id)==0
add_to_zigzag(_id,value,bindex)
else
ifdir==1andvalue>array.get(_id,0)ordir==-1andvalue<array.get(_id,0)
array.set(_id,0,value)
array.set(_id,1,bindex)
0.
ifphorpl
ifdirchanged
add_to_zigzag(arr_zz,dir==1?ph:pl,bar_index)
else
update_zigzag(arr_zz,dir==1?ph:pl,bar_index,dir)
ifarray.size(arr_zz)>=6
//Variables
varlabellabel_zz=na
//Boolsforor
boolbool_or_1=array.get(arr_zz,0)!=array.get(older_zz,0)
boolbool_or_2=array.get(arr_zz,1)!=array.get(older_zz,1)

//Boolsforand
boolbool_n_1=array.get(arr_zz,2)==array.get(older_zz,2)
boolbool_n_2=array.get(arr_zz,3)==array.get(older_zz,3)

//Boolsformorethanandlessthan
boolbool_0_mt_4=array.get(arr_zz,0)>array.get(arr_zz,4)
boolbool_0_lt_4=array.get(arr_zz,0)<array.get(arr_zz,4)

ifbool_or_1orbool_or_2
ifbool_n_1andbool_n_2
label.delete(label_zz)
str_label=dir==1?bool_0_mt_4?'â–¼':'â–¼':
bool_0_lt_4?'â–²':'â–²'
col_label=dir==1?bool_0_mt_4?color.red:color.teal:
bool_0_lt_4?color.teal:color.red
ifi_show_crsi
label_zz:=label.new(bar_index,high,text=str_label,color=color.new(color.blue,100),textcolor=col_label,style=dir==1?label.style_label_down:label.style_label_up)
ifdir==1
cRSI_high_extreme_found:=close
cRSI_low_extreme_found:=0.0
last_cRSI_extreme:="high"
else
cRSI_low_extreme_found:=close
cRSI_high_extreme_found:=0.0
last_cRSI_extreme:="low"
iflast_cRSI_extreme=="high"andcRSI_high_extreme_found>0.0
cRSI_trend_direction:="sell"
iflast_cRSI_extreme=="low"andcRSI_low_extreme_found>0.0
cRSI_trend_direction:="buy"
//------------------------------------------------------------------------------
//MESAadaptivemovingaverageindicatorcode
//------------------------------------------------------------------------------
tf1=_tf=='0'?timeframe.period:_tf
fast=0.25
slow=0.05
//Returnsscalardifferencebetweencurrenttimeframeandrequested
ResolutionToMin(tf)=>
mins=tf=="1M"?43830:tf=="1W"?10080:tf=="1D"?1440:tf=="240"?240:tf=="180"?180:tf=="120"?120:tf=="60"?60:tf=="45"?45:tf=="30"?30:tf=="15"?15:tf=="5"?5:tf=="3"?3:tf=="1"?1:-1
mins
chart_res=ResolutionToMin(timeframe.period)
if(timeframe.isdwm)
chart_res:=ResolutionToMin(str.tostring(timeframe.multiplier)+timeframe.period)
req_res=ResolutionToMin(_tf)
scale=req_res==-1orchart_res==-1orchart_res>req_res?1:chart_res/req_res


//MESAMovingAverage`
//Args:src-theseriestoperformMAMAcalculationson
//fast-limittothefastmovingaveragecalc(default0.5)
//slow-limittotheslowmovingaveragecalc(default0.05)
//hide-forusagewithmultipleMESAplots.settoTruetoreturn[na,na]
//##############################################################################
getMESA(src_in,fast,slow,show)=>
Price=src_in
FastLimit=fast
SlowLimit=slow
MAMA=src_in
FAMA=src_in
PI=3.14159
Smooth=0.0
Detrender=0.0
I1=0.0
Q1=0.0
jI=0.0
jQ=0.0
I2=0.0
Q2=0.0
Re=0.0
Im=0.0
Period=0.0
SmoothPeriod=0.0
Phase=0.0
DeltaPhase=0.0
alpha=0.0
if(na(Price))
MAMA:=MAMA[1]
FAMA:=FAMA[1]
Smooth:=Smooth[1]
Detrender:=Detrender[1]
I1:=I1[1]
Q1:=Q1[1]
I2:=I2[1]
Q2:=Q2[1]
Re:=Re[1]
Im:=Im[1]
Period:=Period[1]
SmoothPeriod:=SmoothPeriod[1]
Phase:=Phase[1]

if(bar_index>5andshowandnotna(Price))
Smooth:=(4*Price+3*Price[1]+2*Price[2]+Price[3])/10
Detrender:=(0.0962*Smooth+0.5769*Smooth[2]-0.5769*Smooth[4]-0.0962*Smooth[6])*
(0.075*Period[1]+0.54)
//GettheInphase&QuadtratureComponents
Q1:=(0.0962*Detrender+0.5769*Detrender[2]-0.5769*Detrender[4]-
0.0962*Detrender[6])*(0.075*Period[1]+0.54)
I1:=Detrender[3]
//Advancephaseangleby90deg
jI:=(0.0962*I1+0.5769*I1[2]-0.5769*I1[4]-0.0962*I1[6])*
(0.075*Period[1]+0.54)
jQ:=(0.0962*Q1+0.5769*Q1[2]-0.5769*Q1[4]-0.0962*Q1[6])*
(0.075*Period[1]+0.54)
//Phasoradditionfor3-baraveraging
I2:=I1-jQ
Q2:=Q1+jI
//SmooththeIandQcomponentsbeforeapplyingthediscriminator
I2:=0.2*I2+0.8*I2[1]
Q2:=0.2*Q2+0.8*Q2[1]
//HomodyneDiscriminator
Re:=I2*I2[1]+Q2*Q2[1]
Im:=I2*Q2[1]-Q2*I2[1]
Re:=0.2*Re+0.8*Re[1]
Im:=0.2*Im+0.8*Im[1]
ifIm!=0andRe!=0
Period:=2*PI/math.atan(Im/Re)
Period:=Period>1.5*Period[1]?1.5*Period[1]:Period
Period:=Period>50?50:Period
Period:=Period<0.67*Period[1]?0.67*Period[1]:Period
Period:=Period<6?6:Period
Period:=0.2*Period+0.8*Period[1]
SmoothPeriod:=0.33*Period+0.67*SmoothPeriod[1]
ifI1!=0
Phase:=180/PI*math.atan(Q1/I1)
DeltaPhase:=Phase[1]-Phase
ifDeltaPhase<1
DeltaPhase:=1
alpha:=FastLimit/DeltaPhase
alpha:=alpha<SlowLimit?SlowLimit:alpha
alpha:=alpha>FastLimit?FastLimit:alpha
MAMA:=alpha*Price+(1-alpha)*MAMA[1]
FAMA:=0.5*alpha*MAMA+(1-0.5*alpha)*FAMA[1]
if(notshow)
MAMA:=na
FAMA:=na
[MAMA,FAMA]
[M_1,F_1]=getMESA(close,fast*scale,slow*scale,true)
//SimplefunctiontograbthecolorofthefillgivenaMama/Famatuple
//Args:mama-theMesaadaptivemovingaverage
//fama-thefollowermovingaverage(generatedbyprior)
//##############################################################################
fillColor(mama,fama,show)=>
color_1=color.new(color.white,100)
ret=show?mama>fama?color.red:color.blue:color_1
ret
//##############################################################################
p_m_1=plot(M_1,"MAMAonHTFAdaptiveMESA",i_show_htf_mesa?color.maroon:na,2)
p_f_1=plot(F_1,"FAMAonHTFAdaptiveMESA",i_show_htf_mesa?color.navy:na,2)
fill_1=fillColor(M_1,F_1,i_show_htf_mesa)
fill(p_m_1,p_f_1,fill_1,"Fill1")
ifmesa_ma_trend_direction==""orta.cross(M_1,F_1)
ifM_1>F_1
mesa_ma_trend_direction:="up"
else
mesa_ma_trend_direction:="down"
//CANDLESCODE
//checksSLpricetobeatthehighest/lowestpointforcurrentBigCandle'strendend
calculate_sl()=>
new_sl=sl_price
current_bar_trend=(close>open?"up":"down")
ifsl_ends_with_trendandmax_sl_percent==0
bar_index_counter=0
//label.new(bar_index-bar_index_counter,low-150,"time:"+str.tostring(math.ceil(pivots_history_check_mins*60/timeframe.in_seconds(timeframe.period)))+"/high:"+str.tostring(pivot_high)+"/"+str.tostring(pivot_low))

whilebar_index_counter<5000
ifopen[bar_index_counter]==last_big_candle_openandclose[bar_index_counter]==last_big_candle_closeandhigh[bar_index_counter]==last_big_candle_highandlow[bar_index_counter]==last_big_candle_low
break
else
bar_index_counter:=bar_index_counter+1

if(current_bar_trend=="up"andlow[bar_index_counter]<new_sl)
new_sl:=low[bar_index_counter]
elseif(current_bar_trend=="down"andhigh[bar_index_counter]>new_sl)
new_sl:=high[bar_index_counter]
//extendSL,ifneeded
ifnew_sl!=sl_priceandextend_sl_by>0
ifcurrent_bar_trend=="up"
new_sl:=new_sl-((extend_sl_by/100)*new_sl)
else
new_sl:=new_sl+((extend_sl_by/100)*new_sl)
new_sl
//calculatesTPbygoingbackthroughpreviousbarsuntilanoppositeoneisfound
calculate_tp()=>
current_bar_trend=(close>open?"up":"down")
floattp_found=0.0
boolfirst_opposite_found=false
boolstart_counting=false//don'tstartcountingbeforeweactuallyreachtheoriginalcandle
bar_index_counter=1
//label.new(bar_index-bar_index_counter,low-150,"time:"+str.tostring(math.ceil(pivots_history_check_mins*60/timeframe.in_seconds(timeframe.period)))+"/high:"+str.tostring(pivot_high)+"/"+str.tostring(pivot_low))
whiletp_found==0.0andbar_index_counter<5000
//checkifwe'vefoundthelastbigcandlefromwhichtostartthecount
ifnot(start_counting)
ifopen[bar_index_counter]==last_big_candle_openandclose[bar_index_counter]==last_big_candle_closeandhigh[bar_index_counter]==last_big_candle_highandlow[bar_index_counter]==last_big_candle_low
start_counting:=true
else
bar_index_counter:=bar_index_counter+1
//ifwe'venotreachedthecandletostartcountingfrom,don'tdoanythingyet
ifnot(start_counting)
continue
//label.new(bar_index-bar_index_counter,low-150,"tp/"+str.tostring(current_bar_trend)+"/"+(close[bar_index_counter]>open[bar_index_counter]?"up":"down"))
if(not(first_opposite_found)and((current_bar_trend=="up"andclose[bar_index_counter]<open[bar_index_counter])or(current_bar_trend=="down"andopen[bar_index_counter]<close[bar_index_counter])))
first_opposite_found:=true
iffirst_opposite_foundand((current_bar_trend=="up"andclose[bar_index_counter]>open[bar_index_counter])or(current_bar_trend=="down"andopen[bar_index_counter]>close[bar_index_counter]))
//label.new(bar_index-bar_index_counter,low-250,"found")
tp_found:=(current_bar_trend=="up"?high[bar_index_counter-1]:low[bar_index_counter-1])
//checkifweneedtoextendtheTP
ifextend_tp_by>0
//calculatehowmuchtoaddtoourTP
ifcurrent_bar_trend=="up"
tp_found:=high[bar_index_counter-1]+((extend_tp_by/100)*high[bar_index_counter-1])
else
tp_found:=low[bar_index_counter-1]-((extend_tp_by/100)*low[bar_index_counter-1])
//label.new(bar_index-bar_index_counter,low-200,"found:"+str.tostring(tp_found))
bar_index_counter:=bar_index_counter+1
tp_found
//BIGCANDLESCODE
prev_candle_size=percentage?close[1]*size/100:size
prev_up_candle=close[1]>open[1]andhigh[1]-low[1]>=prev_candle_size
prev_down_candle=close[1]<open[1]andhigh[1]-low[1]>=prev_candle_size
plotshape(prev_up_candle,"UpCandle",style=shape.triangleup,color=color.green,location=location.belowbar,size=size.tiny,offset=-1)
plotshape(prev_down_candle,"DownCandle",style=shape.triangledown,color=color.red,location=location.abovebar,size=size.tiny,offset=-1)
candle_size=percentage?close*size/100:size
//label.new(bar_index,high,"size/"+str.tostring(prev_candle_size)+"/"+str.tostring(candle_size))
//ifprev_up_candleorprev_down_candle
//label.new(bar_index,high,"found,"+(prev_up_candle?"up":"down")+",tp"+str.tostring(exit_price)+"/sl"+str.tostring(sl_price))
//helperfunctionsinceta.cross()don'tseemtoworkcorrectlywithhistoricalvaluesandPivotPointscode
has_crossed(candle_type,candle_high,candle_low,level)=>
(candle_type=="up"andcandle_low<levelandcandle_high>level)or(candle_type=="down"andcandle_high>levelandcandle_low<level)
//ifwefoundoutthatthepreviouscandleisabigcandle,storeitstypeandtheretracementpointandalsocalculateSLlevelincasewe'llopenatradeforit
if(prev_up_candleorprev_down_candle)andexit_price==0.0
has_required_prev_bars=true
//checkwhetherwehaveatleastthepredefinedamountofbarsgoingwiththetrendoftheBigCandle
ifrequire_previous_same_bars>0
fori=2to2+require_previous_same_bars
ifprev_up_candleandopen[i]>close[i]
has_required_prev_bars:=false
break
ifprev_down_candleandclose[i]>open[i]
has_required_prev_bars:=false
break
ifhas_required_prev_bars
last_big_candle_type:=(prev_up_candle?"up":"down")
last_big_candle_high:=high[1]
last_big_candle_low:=low[1]
last_big_candle_open:=open[1]
last_big_candle_close:=close[1]

retrace_value=((high[1]-low[1])/100)*min_retracement
iflast_big_candle_type=="up"
last_big_candle_retrace_level:=high[1]-retrace_value
ifextend_sl_by==0
sl_price:=high[1]
else
sl_price:=high[1]+((extend_sl_by/100)*high[1])

//checkiftheSLpriceisnotbeyondourmaxSLprice
ifmax_sl_percent>0
sl_price:=close[1]-((max_sl_percent/100)*close[1])
else
last_big_candle_retrace_level:=low[1]+retrace_value
ifextend_sl_by==0
sl_price:=low[1]
else
sl_price:=low[1]-((extend_sl_by/100)*low[1])

//checkiftheSLpriceisnotbeyondourmaxSLprice
ifmax_sl_percent>0
sl_price:=close[1]+((max_sl_percent/100)*close[1])

//storewhichpivotlevelsdidourcandlecross
ifarray.size(s5)>0
ifhas_crossed(last_big_candle_type,high[1],low[1],array.get(s5,array.size(s5)-1))
array.set(last_big_candle_pivots_closed,0,array.get(s5,array.size(s5)-1))
else
array.set(last_big_candle_pivots_closed,0,0.0)
else
array.set(last_big_candle_pivots_closed,0,0.0)

ifarray.size(s4)>0
ifhas_crossed(last_big_candle_type,high[1],low[1],array.get(s4,array.size(s4)-1))
array.set(last_big_candle_pivots_closed,1,array.get(s4,array.size(s4)-1))
else
array.set(last_big_candle_pivots_closed,1,0.0)
else
array.set(last_big_candle_pivots_closed,1,0.0)

ifarray.size(s3)>0
ifhas_crossed(last_big_candle_type,high[1],low[1],array.get(s3,array.size(s3)-1))
array.set(last_big_candle_pivots_closed,2,array.get(s3,array.size(s3)-1))
else
array.set(last_big_candle_pivots_closed,2,0.0)
else
array.set(last_big_candle_pivots_closed,2,0.0)

ifarray.size(s2)>0
ifhas_crossed(last_big_candle_type,high[1],low[1],array.get(s2,array.size(s2)-1))
array.set(last_big_candle_pivots_closed,3,array.get(s2,array.size(s2)-1))
else
array.set(last_big_candle_pivots_closed,3,0.0)
else
array.set(last_big_candle_pivots_closed,3,0.0)

ifarray.size(s1)>0
ifhas_crossed(last_big_candle_type,high[1],low[1],array.get(s1,array.size(s1)-1))
array.set(last_big_candle_pivots_closed,4,array.get(s1,array.size(s1)-1))
else
array.set(last_big_candle_pivots_closed,4,0.0)
else
array.set(last_big_candle_pivots_closed,4,0.0)

ifarray.size(p)>0
ifhas_crossed(last_big_candle_type,high[1],low[1],array.get(p,array.size(p)-1))
array.set(last_big_candle_pivots_closed,5,array.get(p,array.size(p)-1))
else
array.set(last_big_candle_pivots_closed,5,0.0)
else
array.set(last_big_candle_pivots_closed,5,0.0)

ifarray.size(r1)>0
ifhas_crossed(last_big_candle_type,high[1],low[1],array.get(r1,array.size(r1)-1))
array.set(last_big_candle_pivots_closed,6,array.get(r1,array.size(r1)-1))
else
array.set(last_big_candle_pivots_closed,6,0.0)
else
array.set(last_big_candle_pivots_closed,6,0.0)

ifarray.size(r2)>0
ifhas_crossed(last_big_candle_type,high[1],low[1],array.get(r2,array.size(r2)-1))
array.set(last_big_candle_pivots_closed,7,array.get(r2,array.size(r2)-1))
else
array.set(last_big_candle_pivots_closed,7,0.0)
else
array.set(last_big_candle_pivots_closed,7,0.0)

ifarray.size(r3)>0
ifhas_crossed(last_big_candle_type,high[1],low[1],array.get(r3,array.size(r3)-1))
array.set(last_big_candle_pivots_closed,8,array.get(r3,array.size(r3)-1))
else
array.set(last_big_candle_pivots_closed,8,0.0)
else
array.set(last_big_candle_pivots_closed,8,0.0)

ifarray.size(r4)>0
ifhas_crossed(last_big_candle_type,high[1],low[1],array.get(r4,array.size(r4)-1))
array.set(last_big_candle_pivots_closed,9,array.get(r4,array.size(r4)-1))
else
array.set(last_big_candle_pivots_closed,9,0.0)
else
array.set(last_big_candle_pivots_closed,9,0.0)

ifarray.size(r5)>0
ifhas_crossed(last_big_candle_type,high[1],low[1],array.get(r5,array.size(r5)-1))
array.set(last_big_candle_pivots_closed,10,array.get(r5,array.size(r5)-1))
else
array.set(last_big_candle_pivots_closed,10,0.0)
else
array.set(last_big_candle_pivots_closed,10,0.0)
//label.new(bar_index,low-100,"found/"+(prev_up_candle?"prevup":"prevdown")+"/"+str.tostring(retrace_value)+"/"+str.tostring(last_big_candle_retrace_level))
//label.new(bar_index,low-100,"found/"+(prev_up_candle?"prevup":"prevdown")+"/"+str.tostring(last_big_candle_retrace_level))
//ifprev_up_candleorprev_down_candle
//label.new(bar_index,high+150,"found(2),"+(prev_up_candle?"up":"down")+",tp"+str.tostring(exit_price)+"/sl"+str.tostring(sl_price))
//closecurrenttradeifwereachedourTP
//label.new(bar_index,high+150,str.tostring(strategy.opentrades)+"/"+strategy.opentrades.entry_id(strategy.opentrades-1)+"/"+str.tostring(close)+"/"+str.tostring(exit_price))
ifstrategy.opentrades>0and((strategy.opentrades.entry_id(strategy.opentrades-1)=="Buy"andclose>=exit_price)or(strategy.opentrades.entry_id(strategy.opentrades-1)=="Sell"andclose<=exit_price))
strategy.close(strategy.opentrades.entry_id(strategy.opentrades-1),comment="TPReached")
exit_price:=0.0
sl_price:=0.0
//closetradeisastoplosswasreached
ifstrategy.opentrades>0and((strategy.opentrades.entry_id(strategy.opentrades-1)=="Buy"andclose<sl_price)or(strategy.opentrades.entry_id(strategy.opentrades-1)=="Sell"andclose>sl_price))
strategy.close(strategy.opentrades.entry_id(strategy.opentrades-1),comment="closedbySL")
exit_price:=0.0
sl_price:=0.0
//label.new(bar_index,high,"info/"+last_big_candle_type+"/"+str.tostring(last_big_candle_retrace_level)+"/ex:"+str.tostring(exit_price)+"/sl:"+str.tostring(sl_price))
//ifwehavepreviouslystoredbigcandlevalues,checkifourcurrentcandledoesn'tretracetothestoredposition
iflast_big_candle_type!=""andexit_price==0.0andsl_price>0.0
retraces=(last_big_candle_type=="up"?close<last_big_candle_retrace_level:close>last_big_candle_retrace_level)
//label.new(bar_index,high,"info/"+last_big_candle_type+"/"+str.tostring(last_big_candle_retrace_level))
//label.new(bar_index,high,"info/"+last_big_candle_type+"/"+str.tostring(retraces)+"/"+str.tostring(last_big_candle_retrace_level)+"/"+str.tostring(close))
//currentcandleretracesthegivenpercentage,openatrade
ifretracesandinDateRange//and(strategy.opentrades==0orstrategy.opentrades.entry_id(strategy.opentrades-1)!=(last_big_candle_type=="up"?"Sell":"Buy"))
//label.new(bar_index,high,"go/"+last_big_candle_type+"/"+str.tostring(retraces)+"/"+str.tostring(last_big_candle_retrace_level)+"/"+str.tostring(close)+"/sl:"+str.tostring(sl_price))
//checkwhetherthelastcandlecrossedatleast2pivots
has_valid_pivot_cross=false
pivots_crossed=0
floatpivot_crossed_value=na
fori=0toarray.size(last_big_candle_pivots_closed)-1
ifarray.get(last_big_candle_pivots_closed,i)>0
pivots_crossed:=pivots_crossed+1
ifna(pivot_crossed_value)
pivot_crossed_value:=array.get(last_big_candle_pivots_closed,i)
if(last_big_candle_type=="down"andarray.get(last_big_candle_pivots_closed,i)<pivot_crossed_value)or(last_big_candle_type=="up"andarray.get(last_big_candle_pivots_closed,i)>pivot_crossed_value)
pivot_crossed_value:=array.get(last_big_candle_pivots_closed,i)
//label.new(bar_index,high+150,"crossed"+str.tostring(pivots_crossed)+""+last_big_candle_type)
ifpivots_crossed>1
has_valid_pivot_cross:=true
elseifpivots_crossed>0
//thelastbigcandlecrossedatleastasinglepivotlevel,
//checkwhetherthecrosswasatleastbythepredefinednumberof%ormoreofthecandleitself
pivot_position=((last_big_candle_type=="up"?(pivot_crossed_value-last_big_candle_low):(last_big_candle_high-pivot_crossed_value))/(last_big_candle_high-last_big_candle_low))*100
//label.new(bar_index,high,str.tostring(last_big_candle_type)+"/"+str.tostring(last_big_candle_high)+"/"+str.tostring(last_big_candle_low)+"/"+str.tostring(pivot_crossed_value)+"/"+str.tostring(pivot_position))
ifpivot_position>=pivot_cross_by_at_least_perc
has_valid_pivot_cross:=true
iflast_big_candle_type=="up"
exit_price:=calculate_tp()
sl_price:=calculate_sl()
//pivot_position
ifhas_valid_pivot_crossandexit_price>0.0andexit_price<closeand(not(i_use_crsi)orcRSI_trend_direction=="sell")and(noti_use_htf_mesaormesa_ma_trend_direction=="down")
strategy.entry("Sell",strategy.short,comment="Sell(tp"+str.tostring(exit_price)+"/sl"+str.tostring(sl_price)+")")
//label.new(bar_index,high,str.tostring(last_bar_index)+"/"+str.tostring(exit_price))
//strategy.exit("Sell",stop=sl_price,comment="closedbySL/tp"+str.tostring(exit_price)+"/sl"+str.tostring(sl_price)+"/dir"+last_trade_direction)
else
exit_price:=0.0
else
exit_price:=calculate_tp()
sl_price:=calculate_sl()
//label.new(bar_index,high+150,"going"+str.tostring(exit_price))
ifhas_valid_pivot_crossandexit_price>0.0andexit_price>closeand(not(i_use_crsi)orcRSI_trend_direction=="buy")and(noti_use_htf_mesaormesa_ma_trend_direction=="up")
strategy.entry("Buy",strategy.long,comment="Buy(tp"+str.tostring(exit_price)+"/sl"+str.tostring(sl_price)+")")
//label.new(bar_index,high,str.tostring(last_bar_index)+"/"+str.tostring(exit_price))
//strategy.exit("Buy",stop=sl_price,comment="closedbySL/tp"+str.tostring(exit_price)+"/sl"+str.tostring(sl_price)+"/dir"+last_trade_direction)
else
exit_price:=0.0
//Exitopenmarketpositionwhendaterangeends
if(notinDateRange)
strategy.close_all()
Expand (1014 lines)
